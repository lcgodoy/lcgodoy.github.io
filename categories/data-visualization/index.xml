<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Visualization | Academic</title>
    <link>/categories/data-visualization/</link>
      <atom:link href="/categories/data-visualization/index.xml" rel="self" type="application/rss+xml" />
    <description>Data Visualization</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019</copyright><lastBuildDate>Sat, 16 Jun 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>/img/logo2.png</url>
      <title>Data Visualization</title>
      <link>/categories/data-visualization/</link>
    </image>
    
    <item>
      <title>A simple plot for correlation between response and explanatory variables</title>
      <link>/post/2018/06/2018-06-16-correlation/</link>
      <pubDate>Sat, 16 Jun 2018 00:00:00 +0000</pubDate>
      <guid>/post/2018/06/2018-06-16-correlation/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In this post I&amp;rsquo;ll explain very briefly how to build a bar correlation plot using
&lt;code&gt;ggplot2&lt;/code&gt; and &lt;code&gt;dplyr&lt;/code&gt;. Such graphs are interesting to examine the relationship
between a outcome of interest and explanatory variables, which is an important
task that anteceds a regression analysis. It is important to remember that
Pearson Correlation give us a linear correlation. Consequently a low
linear correlation doesn&amp;rsquo;t necessarily implies that there are no correlation
between two variables, because such correlation can follow a non-linear pattern.
Another very interesting remark is the famous quote &amp;ldquo;Correlation is not
causation!&amp;ldquo;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The data used is the well know &lt;code&gt;mtcars&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;straight-to-the-point&#34;&gt;Straight to the point&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s say that we are interest in verify which variables have high correlations
with &lt;code&gt;mpg&lt;/code&gt;. To do it, use the following piece of code to compute the correlation matrix
for the data and then select just first the line of the matrix corresponding to the
variable of interest, after this, exclude the first position of the resulting
vector.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(dplyr)
library(ggplot2)
library(magrittr)

correlation &amp;lt;- cor(mtcars)[1,][-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In matter of fact, the pearson correlation is not adequated to measure correlation
between variables that are not continuous. However, it&amp;rsquo;s just a toy example to
show how to create a specific plot.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now that the correlations have already been computed, store it in a &lt;code&gt;tibble&lt;/code&gt;
(this is not necessarily, but make the code more organized). Note that the
&lt;code&gt;Covariates&lt;/code&gt; variable is being reordered by the correlation. As consequence,
when the data is plotted, the bars will be ordered by the correlation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df &amp;lt;- tibble(Covariates = names(correlation),
             Correlation = correlation) %&amp;gt;% 
  mutate(Covariates = factor(Covariates, 
                             levels = Covariates[order(.$Correlation, 
                                                       decreasing = T)]
  )
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the following piece of code, the argument &lt;code&gt;fill = as.factor(sign(Correlation))&lt;/code&gt; will
give different colors for negative and positive correlations, this colors are specified
with &lt;code&gt;scale_fill_manual&lt;/code&gt;. Also, &lt;code&gt;stat = &#39;identity&#39;&lt;/code&gt; is necessary because the default of
&lt;code&gt;geom_bar&lt;/code&gt; assumes a count. In &lt;code&gt;geom_text&lt;/code&gt;, the argument &lt;code&gt;vjust&lt;/code&gt; needs to be multiplied
by &lt;code&gt;sign(Correlation)&lt;/code&gt; since the bars assume positive and negative values and such
parameter needs to be different for each of these two cases.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(df) +
  geom_bar(aes(x = Covariates, y = Correlation, fill = as.factor(sign(Correlation))),
           stat = &#39;identity&#39;, width = .6) +
  geom_text(aes(x = Covariates, y = Correlation, 
                label = formatC(Correlation, digits = 2)),
            vjust = sign(df$Correlation)*1.6,
            color = &#39;white&#39;, 
            size = 3.5)+
  scale_fill_manual(values = c(&#39;#9b1d1d&#39;, &#39;#129127&#39;)) +
  guides(fill = F) +
  labs(y = expression(rho(X[i], Y)),
       x = expression(X[i])) +
  theme_bw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/post/2018/06/2018-06-16-correlation_files/figure-html/plot1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note that the plot above can have another interesting ordering for the bars. If we
order the variable &lt;code&gt;Covariates&lt;/code&gt; by the absolute value of the &lt;code&gt;Correlation&lt;/code&gt;, then
we&amp;rsquo;ll have the plot ordered by the strength of the correlation, independently
from its signal. Sometimes such approach is more interesting and it is showed in the
next piece of code. There is just one subtle alteration, apply the function
&lt;code&gt;abs&lt;/code&gt; to &lt;code&gt;.$Correlation&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;df %&amp;lt;&amp;gt;% mutate(Covariates = factor(Covariates, 
                                   levels = Covariates[order(abs(.$Correlation), 
                                                             decreasing = T)]))

ggplot(df) +
  geom_bar(aes(x = Covariates, y = Correlation, fill = as.factor(sign(Correlation))),
           stat = &#39;identity&#39;, width = .6) +
  geom_text(aes(x = Covariates, y = Correlation, 
                label = formatC(Correlation, digits = 2)),
            vjust = sign(df$Correlation)*1.6,
            color = &#39;white&#39;, 
            size = 3.5)+
  scale_fill_manual(values = c(&#39;#9b1d1d&#39;, &#39;#129127&#39;)) +
  guides(fill = F) +
  labs(y = expression(rho(X[i], Y)),
       x = expression(X[i])) +
  theme_bw()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/post/2018/06/2018-06-16-correlation_files/figure-html/plot2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, that&amp;rsquo;s it. Hope that you liked.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WordClouds - Visualizing gender inequality in income</title>
      <link>/post/2018/05/2018-05-02-wordcloud/</link>
      <pubDate>Wed, 02 May 2018 00:00:00 +0000</pubDate>
      <guid>/post/2018/05/2018-05-02-wordcloud/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This week I&amp;rsquo;m posting my visualization and a brief analysis about the
&lt;a href=&#34;https://twitter.com/R4DScommunity/status/988790036014485504&#34; target=&#34;_blank&#34;&gt;#TidyTuesday week 4&lt;/a&gt;.
The challenge was about the disparity between men and women when analysing their
average incomes.&lt;br /&gt;
The data provided was organized as follows:&lt;/p&gt;

&lt;p&gt;&lt;!--html_preserve--&gt;&lt;div id=&#34;DT&#34; style=&#34;width:100%;height:100%;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;DT&#34;&gt;{&amp;ldquo;x&amp;rdquo;:{&amp;ldquo;url&amp;rdquo;:&amp;ldquo;/post/2018/05/2018-05-02-wordcloud_files/figure-html//widgets/widget_data1.html&amp;rdquo;,&amp;ldquo;options&amp;rdquo;:{&amp;ldquo;xdomain&amp;rdquo;:&amp;rdquo;*&amp;ldquo;,&amp;ldquo;allowfullscreen&amp;rdquo;:false,&amp;ldquo;lazyload&amp;rdquo;:false}},&amp;ldquo;evals&amp;rdquo;:[],&amp;ldquo;jsHooks&amp;rdquo;:[]}&lt;/script&gt;&lt;!--/html_preserve--&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://data.gov.au/dataset/taxation-statistics-2013-14/resource/c506c052-be2f-4fba-8a65-90f9e60f7775?inner_span=True&#34; target=&#34;_blank&#34;&gt;data souce&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.womensagenda.com.au/latest/eds-blog/australia-s-50-highest-paying-jobs-are-paying-men-significantly-more/&#34; target=&#34;_blank&#34;&gt;An article about it&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hypothesis&#34;&gt;Hypothesis&lt;/h2&gt;

&lt;p&gt;In the dataset there are a lot of &lt;em&gt;composite occupations&lt;/em&gt;, i.e., occupations
that have large descriptions or are compoused by two or more different roles.
Due to it, I would like to see if there are words in these occupations that appears
more in female individuals. In addition, would be nice visualize the average
income associated with each word. To make this &amp;ldquo;average income per word&amp;rdquo;
comparable, it was categorized by its percentile.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you are not interested in &lt;em&gt;how to&lt;/em&gt; build the visualization, go directly
to the analysis &lt;a href=&#34;#analysis&#34;&gt;clicking here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data.table&lt;/code&gt; - read the data;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dplyr&lt;/code&gt; - for data manipulation;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;magrittr&lt;/code&gt; - it&amp;rsquo;s not just the &lt;code&gt;%&amp;gt;%&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggplot2&lt;/code&gt; - for creating the legend (certainly it can be done in a more efficient way);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cowplot&lt;/code&gt; - extract ggplot2 legend;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tm&lt;/code&gt; - Text Mining;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stringr&lt;/code&gt; - string handling;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wordcloud2&lt;/code&gt; - wordclouds.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reading-and-manipulating-the-data&#34;&gt;Reading and manipulating the data&lt;/h2&gt;

&lt;p&gt;The following script will read the data and handle with two initial problems:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Encoding&lt;/strong&gt;: I&amp;rsquo;m a Linux user and the data came from Windows. To overcome encoding
problems, we need to switch the encoding to &lt;em&gt;UTF-8&lt;/em&gt;;&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Integer overflow&lt;/strong&gt;: sometimes, in this data, integers are too large. As a consequence
a summation of integers can return a &lt;code&gt;NaN&lt;/code&gt;, when this integer exceeds a certain size. To
remedy this problem, we can turn these integers in numerics.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(tm)
library(magrittr)
library(dplyr)

Data &amp;lt;- data.table::fread(
(&amp;quot;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-04-23/week4_australian_salary.csv&amp;quot;), 
stringsAsFactors = F, data.table = F
) %&amp;gt;% 
as_tibble() %&amp;gt;% 
mutate(occupation = iconv(occupation, from = &amp;quot;WINDOWS-1252&amp;quot;, to = &amp;quot;UTF-8&amp;quot;), # solving encoding problems
     individuals = as.numeric(individuals), # avoiding integer overflow
     individuals = as.numeric(individuals)) # avoiding integer overflow
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After that, I splitted the the data by gender.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;data_split &amp;lt;- split(Data, Data$gender) # split by gender
data_split$Total &amp;lt;- Data # adding a list component with all data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, created a function that returns the &lt;em&gt;frequency&lt;/em&gt; each word appears
and the &lt;em&gt;average income&lt;/em&gt; related to this word.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# if stem is TRUE, words will be &amp;quot;stemmed&amp;quot;

word_counter &amp;lt;- function(data, stem = T) { 
  
  stopwords &amp;lt;- tm::stopwords(&#39;en&#39;) # aux to remove stopwords
  
  if(stem == T) {
    data %&amp;lt;&amp;gt;% 
      mutate(occup_text = occupation %&amp;gt;% stringr::str_to_lower() %&amp;gt;% 
               stringr::str_replace_all(&#39;–&#39;, &amp;quot;&amp;quot;) %&amp;gt;% 
               tm::removePunctuation() %&amp;gt;% 
               tm::removeNumbers() %&amp;gt;% 
               tm::removeWords(stopwords) %&amp;gt;% 
               tm::stemDocument() %&amp;gt;%
               tm::stripWhitespace()) 
    
    dtm &amp;lt;- data$occup_text %&amp;gt;%
      VectorSource() %&amp;gt;% 
      Corpus() %&amp;gt;% 
      TermDocumentMatrix() 
    
    df_word &amp;lt;- as.matrix(dtm) %&amp;gt;% 
      rowSums() %&amp;gt;% 
      sort(decreasing=TRUE) %&amp;gt;% 
      names
  }
  else {
    data %&amp;lt;&amp;gt;% 
      mutate(occup_text = occupation %&amp;gt;% stringr::str_to_lower() %&amp;gt;% 
               stringr::str_replace_all(&#39;–&#39;, &amp;quot;&amp;quot;) %&amp;gt;%
               tm::removePunctuation() %&amp;gt;% 
               tm::removeNumbers() %&amp;gt;% 
               tm::removeWords(stopwords) %&amp;gt;%
               tm::stripWhitespace()) 
    
    dtm &amp;lt;- data$occup_text %&amp;gt;%
      VectorSource() %&amp;gt;% 
      Corpus() %&amp;gt;% 
      TermDocumentMatrix() 
    
    df_word &amp;lt;- as.matrix(dtm) %&amp;gt;% 
      rowSums() %&amp;gt;% 
      sort(decreasing=TRUE) %&amp;gt;% 
      names
  }
  
  df_word$freq &amp;lt;- NA_real_
  df_word$income &amp;lt;- NA_real_
  aux &amp;lt;- NULL
  
  for(i in seq_len(nrow(df_word))) {
    aux &amp;lt;- data[stringr::str_detect(data$occup_text, df_word$word[i]),]
    df_word$freq[i] &amp;lt;- sum(aux$individuals)
    df_word$income[i] &amp;lt;- sum(aux$average_taxable_income*aux$individuals)/df_word$freq[i]
    aux &amp;lt;- NULL
  }
  
  return(df_word)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, the package &lt;code&gt;tm&lt;/code&gt; is used just to create a &lt;code&gt;data.frame&lt;/code&gt; with one line
for each word. Then, &lt;code&gt;stringr&lt;/code&gt; is used to detect the professions that
&amp;ldquo;match&amp;rdquo; with each word. Another important detail is concerned about the
calculation of the &lt;em&gt;average income&lt;/em&gt;. Instead of using
&lt;code&gt;mean(aux$average_taxable_income)&lt;/code&gt;, &lt;code&gt;sum(aux$average_taxable_income*aux$individuals)/df_word$freq[i]&lt;/code&gt;
is used. The first choice would calculate a wrong average. Because the average
income of a word that appeared one time would be treated in the same way that
a word that appeared a hundred times.&lt;/p&gt;

&lt;h2 id=&#34;almost-there&#34;&gt;Almost there&lt;/h2&gt;

&lt;p&gt;Now, we just need to run the following script to obtain everything that wee need
to build the men and women wordclouds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;word_counters &amp;lt;- purrr::map(data_split, word_counter, stem = F)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-color-palette-based-on-quantiles&#34;&gt;Creating a color palette based on quantiles&lt;/h3&gt;

&lt;p&gt;The color palette was created based on the quantiles of the average income
considering both men and women. The palette goes from red to white to blue,
this means that red words are associated with low income and blue with high
income.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;col_pal &amp;lt;- colorRampPalette(colors = c(&amp;quot;#f71616&amp;quot;, &amp;quot;#ffffff&amp;quot;, &amp;quot;#283eff&amp;quot;))
breaks &amp;lt;- quantile(word_counters$Total$income, probs = seq(0, 1, by = .005))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;white values are associated with median income. However, the distribution
of the average income is assymetric.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The following lines of code create a variable called &lt;code&gt;color&lt;/code&gt; that indicates
at each quantile each average income is associated and the respective color.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;word_counters &amp;lt;- purrr::map(word_counters, 
                            function(data) {
                              data %&amp;lt;&amp;gt;%
                                mutate(color = cut(x = income, 
                                                   breaks = breaks, 
                                                   label = col_pal(length(breaks) - 1)
                                )
                                )
                            })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wordclouds&#34;&gt;Wordclouds&lt;/h2&gt;

&lt;p&gt;Finally, we are able to create the desired wordclouds and it can be done with
few lines of code. For example, to create a word cloud for men execute the
following code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;wc_obj_men &amp;lt;- word_counters$Male %&amp;gt;% 
  filter(freq &amp;gt; quantile(freq, .8)) # I&#39;m using just the 20% more frequent words.

men_colors &amp;lt;- wc_obj_men$color

# Data structure utilized by wordcloud2
wc_obj_men %&amp;lt;&amp;gt;% select(word, freq)

(wc_men &amp;lt;- wordcloud2::wordcloud2(data = wc_obj_men, color = men_colors,
                                  backgroundColor = &amp;quot;black&amp;quot;,
                                  shuffle = F, 
                                  size = .5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;!--html_preserve--&gt;&lt;div id=&#34;htmlwidget-03d6fb5fcdfa0c5252b2&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-03d6fb5fcdfa0c5252b2&#34;&gt;{&amp;ldquo;x&amp;rdquo;:{&amp;ldquo;url&amp;rdquo;:&amp;ldquo;/post/2018/05/2018-05-02-wordcloud_files/figure-html//widgets/widget_men_wc_print.html&amp;rdquo;,&amp;ldquo;options&amp;rdquo;:{&amp;ldquo;xdomain&amp;rdquo;:&amp;rdquo;*&amp;ldquo;,&amp;ldquo;allowfullscreen&amp;rdquo;:false,&amp;ldquo;lazyload&amp;rdquo;:false}},&amp;ldquo;evals&amp;rdquo;:[],&amp;ldquo;jsHooks&amp;rdquo;:[]}&lt;/script&gt;&lt;!--/html_preserve--&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Similarly, if you want to visualize the women wordcloud, runs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;wc_obj_women &amp;lt;- word_counters$Female %&amp;gt;% 
  filter(freq &amp;gt; quantile(freq, .8))

women_colors &amp;lt;- wc_obj_women$color

wc_obj_women %&amp;lt;&amp;gt;% select(word, freq)

(wc_women &amp;lt;- wordcloud2::wordcloud2(data = wc_obj_women, color = women_colors,
                                    backgroundColor = &amp;quot;black&amp;quot;,
                                    shuffle = F, 
                                    size = .5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;!--html_preserve--&gt;&lt;div id=&#34;htmlwidget-e69e7b1f5ea8b48b201b&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-e69e7b1f5ea8b48b201b&#34;&gt;{&amp;ldquo;x&amp;rdquo;:{&amp;ldquo;url&amp;rdquo;:&amp;ldquo;/post/2018/05/2018-05-02-wordcloud_files/figure-html//widgets/widget_women_wc_print.html&amp;rdquo;,&amp;ldquo;options&amp;rdquo;:{&amp;ldquo;xdomain&amp;rdquo;:&amp;rdquo;*&amp;ldquo;,&amp;ldquo;allowfullscreen&amp;rdquo;:false,&amp;ldquo;lazyload&amp;rdquo;:false}},&amp;ldquo;evals&amp;rdquo;:[],&amp;ldquo;jsHooks&amp;rdquo;:[]}&lt;/script&gt;&lt;!--/html_preserve--&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;creating-a-legend&#34;&gt;Creating a legend&lt;/h3&gt;

&lt;p&gt;Legend will be created as follows (I&amp;rsquo;m sure it can be done in a more efficient way):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;legends &amp;lt;- ggplot2::ggplot(word_counters$Total, aes(x = freq, y = income, fill = income)) +
  ggplot2::geom_point(alpha = .7) + 
  ggplot2::scale_fill_gradientn(colours = c(&amp;quot;#f71616&amp;quot;, &amp;quot;#ffffff&amp;quot;, &amp;quot;#283eff&amp;quot;), 
                                guide = ggplot2::guide_colorbar(title = &amp;quot;Avg. Income&amp;quot;, 
                                                                title.position = &amp;quot;top&amp;quot;, 
                                                                label.position = &amp;quot;bottom&amp;quot;,
                                                                label.theme = ggplot2::element_text(angle = 90,
                                                                                                    size = 6.5,
                                                                                                    family = &amp;quot;Space Mono&amp;quot;),
                                                                ticks = F),
                                breaks = c(min(breaks), max(breaks)),
                                labels = c(&amp;quot;low&amp;quot;, &amp;quot;high&amp;quot;)) +
  ggplot2::theme(legend.justification = &amp;quot;bottom&amp;quot;, 
                 legend.direction = &amp;quot;horizontal&amp;quot;, 
                 legend.title = ggplot2::element_text(family = &amp;quot;Space Mono&amp;quot;,
                                                      size = 8))


legends &amp;lt;- cowplot::get_legend(legends)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Final WordCloud and Analysis&lt;/h2&gt;

&lt;p&gt;The wordclouds below can be used to extract a lot of information about gender
inequalities in Australia in 2013-14.
For example, take a look at the word &lt;em&gt;office&lt;/em&gt;. Despite the number of women that
plays a role in an office is greater than the number of men, Men have a much
better salary at, probably, the same function. If you analyze carefully both
worclouds, you will be able to identify several diferences in the income
associated with a same word in different genders.&lt;/p&gt;

&lt;p&gt;In conlusion, even in Australia, a country considered developed, the problem of not
treating people of different genders equally exists. It&amp;rsquo;s a sad reality that needs to
be showed and faced.&lt;/p&gt;

&lt;div class = &#34;row&#34;&gt;

&lt;div class = &#34;col-md-6 px-0&#34;&gt;

#### Men

&lt;!--html_preserve--&gt;&lt;div id=&#34;htmlwidget-ba5c9f0d74cd124c892d&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-ba5c9f0d74cd124c892d&#34;&gt;{&#34;x&#34;:{&#34;url&#34;:&#34;/post/2018/05/2018-05-02-wordcloud_files/figure-html//widgets/widget_wc1.html&#34;,&#34;options&#34;:{&#34;xdomain&#34;:&#34;*&#34;,&#34;allowfullscreen&#34;:false,&#34;lazyload&#34;:false}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;&lt;!--/html_preserve--&gt;
&lt;/div&gt;

&lt;div class = &#34;col-md-6 px-0&#34;&gt;

#### Women

&lt;!--html_preserve--&gt;&lt;div id=&#34;htmlwidget-dd15528e6b660adb030a&#34; style=&#34;width:100%;height:480px;&#34; class=&#34;widgetframe html-widget&#34;&gt;&lt;/div&gt;
&lt;script type=&#34;application/json&#34; data-for=&#34;htmlwidget-dd15528e6b660adb030a&#34;&gt;{&#34;x&#34;:{&#34;url&#34;:&#34;/post/2018/05/2018-05-02-wordcloud_files/figure-html//widgets/widget_wc2.html&#34;,&#34;options&#34;:{&#34;xdomain&#34;:&#34;*&#34;,&#34;allowfullscreen&#34;:false,&#34;lazyload&#34;:false}},&#34;evals&#34;:[],&#34;jsHooks&#34;:[]}&lt;/script&gt;&lt;!--/html_preserve--&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&#34;/post/2018/05/2018-05-02-wordcloud_files/figure-html/legend_final-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s important to emphasize that the focus of this post is provide a way
to analyze this data. I&amp;rsquo;m a statistician and professionals from other areas
probably can draw more accurate conclusions about this visualization.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>My first #TidyTuesday - A world map GIF</title>
      <link>/post/2018/04/2018-04-13-world_map_gig/</link>
      <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
      <guid>/post/2018/04/2018-04-13-world_map_gig/</guid>
      <description>

&lt;h2 id=&#34;about-tidytuesday&#34;&gt;About TidyTuesday&lt;/h2&gt;

&lt;p&gt;Tidy tuesday is a nice initiative from &lt;a href=&#34;https://twitter.com/R4DScommunity&#34; target=&#34;_blank&#34;&gt;R4DS online community&lt;/a&gt;.
The goal is is to apply your R skills, get feedback, explore other’s work, and connect with the
greater RStats community.&lt;br /&gt;
Actually, it&amp;rsquo;s also my blogging motivation.&lt;/p&gt;

&lt;h2 id=&#34;the-challenge&#34;&gt;The challenge&lt;/h2&gt;

&lt;p&gt;This post is about the following challenge&lt;/p&gt;

&lt;p&gt;&lt;!--html_preserve--&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/hashtag/r4ds?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#r4ds&lt;/a&gt; presents Week 3 of &lt;a href=&#34;https://twitter.com/hashtag/TidyTuesday?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#TidyTuesday&lt;/a&gt;! Let&amp;#39;s explore global causes of mortality!&lt;br&gt;&lt;br&gt;Make a meaningful graphic, and post your code!&lt;br&gt;&lt;br&gt;Data: &lt;a href=&#34;https://t.co/ygKv8PqOfI&#34;&gt;https://t.co/ygKv8PqOfI&lt;/a&gt;&lt;br&gt;Article: &lt;a href=&#34;https://t.co/MOnlCBzdaL&#34;&gt;https://t.co/MOnlCBzdaL&lt;/a&gt;&lt;br&gt;Blog: &lt;a href=&#34;https://t.co/cZJ94Hhz7U&#34;&gt;https://t.co/cZJ94Hhz7U&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/tidyverse?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#tidyverse&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/rstats?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#rstats&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/dataviz?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#dataviz&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/ggplot2?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#ggplot2&lt;/a&gt; &lt;a href=&#34;https://twitter.com/R4DScommunity?ref_src=twsrc%5Etfw&#34;&gt;@R4DScommunity&lt;/a&gt; &lt;a href=&#34;https://t.co/52rktsOcSQ&#34;&gt;pic.twitter.com/52rktsOcSQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Thomas Mock (@thomas_mock) &lt;a href=&#34;https://twitter.com/thomas_mock/status/985864534832402432?ref_src=twsrc%5Etfw&#34;&gt;April 16, 2018&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;!--/html_preserve--&gt;&lt;/p&gt;

&lt;p&gt;The dataset contains mortality rates for all countries from 1990 to 2016, the aim
was build a meaningful visualization. My idea was show the variation of a specific
cause of death through &lt;em&gt;space-time&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can download the data from &lt;a href=&#34;https://github.com/rfordatascience/tidytuesday/blob/master/data/global_mortality.xlsx&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ingredients&#34;&gt;Ingredients&lt;/h2&gt;

&lt;p&gt;To achieve my goal I used the packages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dplyr&lt;/code&gt; - for data manipulation;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggplot2&lt;/code&gt; - for plotting;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggthemes&lt;/code&gt; - map theme;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sf&lt;/code&gt; - for work with spatial data. This package interacts beautifully with &lt;code&gt;ggplot2&lt;/code&gt;
and &lt;code&gt;dplyr&lt;/code&gt;, which makes spatial data manipulation and visualization very easy (and tidy);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;magick&lt;/code&gt; - to build the GIF&amp;rsquo;s;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;magrittr&lt;/code&gt; - it&amp;rsquo;s not just the &lt;code&gt;%&amp;gt;%&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readxl&lt;/code&gt; - reading .xlsx files;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maps&lt;/code&gt; - get the world map &amp;lsquo;shape&amp;rsquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/WireMonkey&#34; target=&#34;_blank&#34;&gt;Alyssa Goldberg&lt;/a&gt; suggestion:
You can use &lt;code&gt;gganimate&lt;/code&gt; instead of &lt;code&gt;magick&lt;/code&gt;, it will need less lines of code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;reading-and-manipulating-the-data&#34;&gt;Reading and manipulating the data&lt;/h2&gt;

&lt;p&gt;The following code is used to read and make the first manipulations at the data
provided for the challenge. Here, &lt;code&gt;mutate&lt;/code&gt; and &lt;code&gt;case_when&lt;/code&gt;, are being used to
modify the names of some countries to coincide with country names at the
map that will be used.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
library(dplyr)
library(sf)
library(magrittr)

data &amp;lt;- readxl::read_excel(&amp;quot;data/global_mortality.xlsx&amp;quot;) %&amp;gt;% 
  mutate(country = case_when(
    country == &#39;Antigua and Barbuda&#39; ~ &#39;Antigua&#39;,
    country == &#39;United States&#39; | country == &#39;United States and Virgin Islands&#39; ~ &#39;USA&#39;,
    country == &#39;United Kingdom&#39; ~ &#39;UK&#39;,
    country == &#39;England&#39; ~ &#39;UK&#39;,
    country == &#39;Scotland&#39; ~ &#39;UK&#39;,
    country == &#39;Trinidad and Tobago&#39; ~ &#39;Trinidad&#39;,
    TRUE ~ country
  ))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need a map and merge our data with it. This would be a little bit more
difficult if we did not have the &lt;code&gt;sf&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;world_map &amp;lt;- st_as_sf(maps::map(&#39;world&#39;, plot = FALSE, fill = TRUE))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we will merge the data from the map with the data provided by the R4DS
challenge. Thank&amp;rsquo;s to &lt;code&gt;dplyr&lt;/code&gt; and &lt;code&gt;sf&lt;/code&gt;, we can do this with the following
lines of code. Here the variables &lt;code&gt;ID&lt;/code&gt; from &lt;code&gt;world map&lt;/code&gt; and &lt;code&gt;country&lt;/code&gt; from
&lt;code&gt;data&lt;/code&gt; must be equal at each country.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;map_years &amp;lt;- world_map %&amp;gt;% 
  full_join(data, by = c(&#39;ID&#39; = &#39;country&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-gif&#34;&gt;Creating a GIF&lt;/h2&gt;

&lt;h3 id=&#34;building-a-function&#34;&gt;Building a function&lt;/h3&gt;

&lt;p&gt;In order to make easier create a &lt;em&gt;GIF&lt;/em&gt; for different causes of death, I built
the following function. Basically, the inputs are the data and a string representing
the name of the variable corresponding to the cause of death you want to visualize.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;gif_map &amp;lt;- function(data, cause_of_death) {
  # Create limits to fix the scales
  fill_lim &amp;lt;- range(data %$% get(cause_of_death), na.rm = T)
  
  # Split the data set for different years
  data_list &amp;lt;- split(data, data$year)
  
  out &amp;lt;- lapply(data_list, function(data, cause_of_death, fill_lim){
    p &amp;lt;- ggplot(data, aes(fill = get(cause_of_death))) +
      geom_sf(size = .2, color = &#39;black&#39;) +
      scale_fill_gradient(low = &amp;quot;#ffefef&amp;quot;, high = &amp;quot;#720000&amp;quot;, space = &amp;quot;Lab&amp;quot;,
                          na.value = &amp;quot;#c6c6c6&amp;quot;, guide = &amp;quot;colourbar&amp;quot;, 
                          limits = c(fill_lim[1], fill_lim[2]),
                          name = cause_of_death) +
      ggthemes::theme_map() +
      labs(title = paste(&#39;Year:&#39;, unique(data$year))) +
      theme(panel.grid.major = element_line(colour = &#39;gray&#39;, size = .2, linetype = &#39;dashed&#39;),
            legend.position = &#39;bottom&#39;)
    print(p)
  }, cause_of_death, fill_lim)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;using-it&#34;&gt;Using it&lt;/h3&gt;

&lt;p&gt;Now that we built a function, use it&amp;rsquo;s very easy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# Specifying the width, height and resolution
img &amp;lt;- magick::image_graph(width = 800, height = 350, res = 96)

# gif for Homicide mortality rate
gif_map(map_years, &amp;quot;Homicide (%)&amp;quot;)
dev.off()

# building a gif with 8 frames per second
animation &amp;lt;- magick::image_animate(img, fps = 8)

# Visualize it
print(animation)

# Save it
magick::image_write(animation, path = &#39;img/homicide.gif&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/post/2018/04/2018-04-13-world_map_gig_files/figure-html/create_gif2.gif&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;code-with-gganimate&#34;&gt;Code with &lt;code&gt;gganimate&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;There is a option to create the GIF with &lt;code&gt;gganimate&lt;/code&gt;, the syntax is very simple
and it is attached at the following block of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(gganimate)
ggplot(map_years, aes(fill = `Homicide (%)`, frame = years)) +
      geom_sf(size = .2, color = &#39;black&#39;) +
      scale_fill_gradient(low = &amp;quot;#ffefef&amp;quot;, high = &amp;quot;#720000&amp;quot;, space = &amp;quot;Lab&amp;quot;,
                          na.value = &amp;quot;#c6c6c6&amp;quot;, guide = &amp;quot;colourbar&amp;quot;) +
      ggthemes::theme_map() +
      labs(title = paste(&#39;Year:&#39;, unique(data$year))) +
      theme(panel.grid.major = element_line(colour = &#39;gray&#39;, size = .2, linetype = &#39;dashed&#39;),
            legend.position = &#39;bottom&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;final-remarks&#34;&gt;Final remarks&lt;/h2&gt;

&lt;p&gt;At this post I showed how to build GIF&amp;rsquo;s considering space-time data with few
lines of code. I expect that you enjoyed the post, and if you have any doubt or
consideration, you can contact me at twitter or email.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
